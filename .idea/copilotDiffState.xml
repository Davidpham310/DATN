<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/datn/data/repository/LessonRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/datn/data/repository/LessonRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.datn.data.repository&#10;&#10;import android.util.Log&#10;import com.example.datn.core.network.service.lesson.LessonService&#10;import com.example.datn.core.utils.Resource&#10;import com.example.datn.data.local.dao.LessonDao&#10;import com.example.datn.domain.models.Lesson&#10;import com.example.datn.domain.models.LessonContent&#10;import com.example.datn.domain.repository.LessonRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import java.time.Instant&#10;import javax.inject.Inject&#10;&#10;private const val TAG = &quot;LessonRepository&quot;&#10;&#10;class LessonRepositoryImpl @Inject constructor(&#10;    private val service: LessonService,&#10;    private val dao: LessonDao&#10;) : LessonRepository {&#10;&#10;    override fun getLessonsByClass(classId: String): Flow&lt;Resource&lt;List&lt;Lesson&gt;&gt;&gt; = flow {&#10;        emit(Resource.Loading())&#10;        try {&#10;            // Try loading from local cache first&#10;            val localLessons = dao.getLessonsByClass(classId)&#10;            if (localLessons.isNotEmpty()) {&#10;                emit(Resource.Success(localLessons.map { it.toDomain() }))&#10;            }&#10;&#10;            // Then fetch fresh data from network&#10;            val remoteLessons = service.getLessonsByClass(classId)&#10;            remoteLessons.forEach { dao.insertLesson(it.toEntity()) }&#10;            &#10;            emit(Resource.Success(remoteLessons))&#10;            Log.i(TAG, &quot;Loaded ${remoteLessons.size} lessons for class $classId&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error loading lessons for class $classId: ${e.message}&quot;)&#10;            emit(Resource.Error(e.localizedMessage ?: &quot;Could not load lessons&quot;))&#10;        }&#10;    }&#10;&#10;    // Similar implementation for getLessonsByTeacher and getLessonContent...&#10;&#10;    override suspend fun addLesson(lesson: Lesson): Resource&lt;Lesson&gt; {&#10;        return try {&#10;            val newLesson = service.addLesson(lesson) &#10;                ?: return Resource.Error(&quot;Failed to add lesson&quot;)&#10;            dao.insertLesson(newLesson.toEntity())&#10;            Log.i(TAG, &quot;Added new lesson: ${newLesson.title}&quot;)&#10;            Resource.Success(newLesson)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error adding lesson: ${e.message}&quot;)&#10;            Resource.Error(e.localizedMessage ?: &quot;Could not add lesson&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun updateLesson(lesson: Lesson): Resource&lt;Unit&gt; {&#10;        return try {&#10;            if (!service.updateLesson(lesson.id, lesson)) {&#10;                return Resource.Error(&quot;Failed to update lesson&quot;)&#10;            }&#10;            dao.updateLesson(lesson.toEntity())&#10;            Log.i(TAG, &quot;Updated lesson: ${lesson.id}&quot;)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error updating lesson: ${e.message}&quot;)&#10;            Resource.Error(e.localizedMessage ?: &quot;Could not update lesson&quot;)&#10;        }&#10;    }&#10;&#10;    override suspend fun publishLesson(lessonId: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            val lesson = service.getLessonById(lessonId) &#10;                ?: return Resource.Error(&quot;Lesson not found&quot;)&#10;            val updated = lesson.copy(&#10;                isPublished = true,&#10;                publishedAt = Instant.now()&#10;            )&#10;            if (!service.updateLesson(lessonId, updated)) {&#10;                return Resource.Error(&quot;Failed to publish lesson&quot;)&#10;            }&#10;            dao.updateLesson(updated.toEntity())&#10;            Log.i(TAG, &quot;Published lesson: $lessonId&quot;)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error publishing lesson: ${e.message}&quot;)&#10;            Resource.Error(e.localizedMessage ?: &quot;Could not publish lesson&quot;)&#10;        }&#10;    }&#10;&#10;    // Similar implementation for other methods...&#10;&#10;    override suspend fun reorderLessonContents(&#10;        lessonId: String,&#10;        contentIds: List&lt;String&gt;&#10;    ): Resource&lt;Unit&gt; {&#10;        return try {&#10;            val contents = service.getLessonContent(lessonId)&#10;            val contentMap = contents.associateBy { it.id }&#10;            &#10;            contentIds.forEachIndexed { index, id -&gt;&#10;                val content = contentMap[id] ?: return Resource.Error(&quot;Content $id not found&quot;)&#10;                val updated = content.copy(order = index)&#10;                if (!service.updateLessonContent(updated)) {&#10;                    return Resource.Error(&quot;Failed to update content order&quot;)&#10;                }&#10;            }&#10;            &#10;            Log.i(TAG, &quot;Reordered ${contentIds.size} contents in lesson $lessonId&quot;)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error reordering contents: ${e.message}&quot;)&#10;            Resource.Error(e.localizedMessage ?: &quot;Could not reorder contents&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>